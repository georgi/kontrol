<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Kontrol : Kontrol is a small web framework written in Ruby, which runs directly on Rack." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Kontrol</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/georgi/kontrol">View on GitHub</a>

          <h1 id="project_title">Kontrol</h1>
          <h2 id="project_tagline">Kontrol is a small web framework written in Ruby, which runs directly on Rack.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/georgi/kontrol/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/georgi/kontrol/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>Kontrol - a micro framework</h1>

<p>Kontrol is a small web framework written in Ruby, which runs directly
on <a href="http://github.com/chneukirchen/rack">Rack</a>. Basically you can mount a class as rack handler and
attach a set of named routes, which will be used for route recognition
and generation.</p>

<p>All examples can be found in the examples folder of the kontrol
project, which is hosted on <a href="http://github.com/georgi/kontrol">github</a>.</p>

<h2>Quick Start</h2>

<p>We will create a simple Kontrol application with exactly one route
named 'root'. Routes are defined within a block insider your
application class. Each route has a name, a pattern and a block. The
name must be defined to generate paths pointing to this route.</p>

<p><code>hello_world.ru</code>:</p>

<pre><code>class HelloWorld &lt; Kontrol::Application

  def time
    Time.now.strftime "%H:%M:%S"
  end

  map do
    root '/' do
      text "&lt;h1&gt;Hello World at #{time}&lt;/h1&gt;"
    end
  end
end

run HelloWorld.new
</code></pre>

<p>Now run:</p>

<pre><code>rackup hello_world.ru
</code></pre>

<p>Browse to <code>http://localhost:9292</code> and you will see "Hello World".</p>

<h2>Basics</h2>

<p>A Kontrol application is a class, which provides some context to the
defined actions. You will probably use these methods:</p>

<ul>
<li>
<strong>request</strong>: the Rack request object</li>
<li>
<strong>response</strong>: the Rack response object</li>
<li>
<strong>params</strong>: union of GET and POST parameters</li>
<li>
<strong>cookies</strong>: shortcut to request.cookies</li>
<li>
<strong>session</strong>: shortcut to <code>request.env['rack.session']</code>
</li>
<li>
<strong>redirect(path)</strong>: renders a redirect response to specified path</li>
<li>
<strong>render(file, variables)</strong>: render a template with specified variables</li>
<li>
<strong>text(string)</strong>: render a string</li>
</ul><h2>Routing</h2>

<p>Routing is just as simple as using regular expressions with
groups. Each group will be provided as argument to the block.</p>

<p>Create a file named <code>routing.ru</code>:</p>

<pre><code>require 'kontrol'

class Routing &lt; Kontrol::Application
  map do
    pages '/pages/(.*)' do |name|
      text "The path is #{ pages_path name }! "
    end

    archive '/(\d*)/(\d*)' do |year, month|
      text "The path is #{ archive_path year, month }! "
    end
  end
end

run Routing.new
</code></pre>

<p>Now run this application:</p>

<pre><code>rackup routing.ru
</code></pre>

<p>You will now see, how regex groups and parameters are related. For
example if you browse to <code>localhost:9292/2008/12</code>, the app will
display <code>The path is /2008/12</code>.</p>

<p>The inverse operation to route recognition is route generation. That
means a route with one or more groups can generate a url, which will
be recognized this very route.</p>

<p>For example the route <code>/page/(.*)</code> named page will recognize the path
<code>/page/about</code>, which can be generated by using <code>page_path('about')</code>.</p>

<h2>Templates</h2>

<p>Rendering templates is as simple as calling a template file with some
parameters, which are accessible inside the template as instance
variables. Additionally you will need a layout template.</p>

<p>Create a template named <code>templates/layout.rhtml</code>:</p>

<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;%= @content %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>And now another template named <code>templates/page.rhtml</code>:</p>

<pre><code>&lt;h1&gt;&lt;%= @title %&gt;&lt;/h1&gt;
&lt;%= @body %&gt;
</code></pre>

<p>Create a templates.ru file:</p>

<pre><code>require 'kontrol'

class Templates &lt; Kontrol::Application
  map do
    page '/(.*)' do |name|
      render "page.rhtml", :title =&gt; name.capitalize, :body =&gt; "This is the body!"
    end
  end
end

run Templates.new
</code></pre>

<p>Now run this example:</p>

<pre><code>rackup templates.ru
</code></pre>

<p>If you browse to any path on <code>localhost:9292</code>, you will see the
rendered template. Note that the title and body parameters have been
passed to the <code>render</code> call.</p>

<h2>Using GitStore</h2>

<p><a href="http://github.com/georgi/git_store">GitStore</a> is another library, which allows you to store code and
data in a convenient way in a git repository. The repository is
checked out into memory and any data may be saved back into the
repository.</p>

<p>Install [GitStore][] by:</p>

<pre><code>$ gem sources -a http://gems.github.com
$ sudo gem install georgi-git_store
</code></pre>

<p>We create a Markdown file name <code>index.md</code>:</p>

<pre><code>Hello World
===========

This is the **Index** page!
</code></pre>

<p>We have now a simple page, which should be rendered as response. We
create a simple app in a file <code>git_app.ru</code>:</p>

<pre><code>require 'kontrol'
require 'bluecloth'
require 'git_store'

class GitApp &lt; Kontrol::Application

  def initialize(path)
    super
    @store = GitStore.new(path)
  end

  map do
    page '/(.*)' do |name|
      text BlueCloth.new(@store[name + '.md']).to_html
    end
  end
end

run GitApp.new
</code></pre>

<p>Add all the page to your git repository:</p>

<pre><code>git init
git add index.md
git commit -m 'init'
</code></pre>

<p>Run the app:</p>

<pre><code>rackup git_app.ru
</code></pre>

<p>Browse to <code>http://localhost:9292/index</code> and you will see the rendered
page generated from the markdown file.</p>

<p>This application runs straight from the git repository. You can even
delete the page and it will still show up over the web.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Kontrol maintained by <a href="https://github.com/georgi">georgi</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
