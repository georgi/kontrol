{"name":"Kontrol","body":"Kontrol - a micro framework\r\n===========================\r\n\r\nKontrol is a small web framework written in Ruby, which runs directly\r\non [Rack][1]. Basically you can mount a class as rack handler and\r\nattach a set of named routes, which will be used for route recognition\r\nand generation.\r\n\r\nAll examples can be found in the examples folder of the kontrol\r\nproject, which is hosted on [github][2].\r\n\r\n## Quick Start\r\n\r\nWe will create a simple Kontrol application with exactly one route\r\nnamed 'root'. Routes are defined within a block insider your\r\napplication class. Each route has a name, a pattern and a block. The\r\nname must be defined to generate paths pointing to this route.\r\n\r\n`hello_world.ru`:\r\n\r\n    class HelloWorld < Kontrol::Application\r\n      \r\n      def time\r\n        Time.now.strftime \"%H:%M:%S\"\r\n      end\r\n     \r\n      map do\r\n        root '/' do\r\n          text \"<h1>Hello World at #{time}</h1>\"\r\n        end\r\n      end\r\n    end\r\n        \r\n    run HelloWorld.new\r\n    \r\nNow run:\r\n\r\n    rackup hello_world.ru\r\n\r\nBrowse to `http://localhost:9292` and you will see \"Hello World\".\r\n\r\n\r\n## Basics\r\n\r\nA Kontrol application is a class, which provides some context to the\r\ndefined actions. You will probably use these methods:\r\n\r\n- __request__: the Rack request object\r\n- __response__: the Rack response object\r\n- __params__: union of GET and POST parameters\r\n- __cookies__: shortcut to request.cookies\r\n- __session__: shortcut to `request.env['rack.session']`\r\n- __redirect(path)__: renders a redirect response to specified path\r\n- __render(file, variables)__: render a template with specified variables\r\n- __text(string)__: render a string\r\n\r\n\r\n## Routing\r\n\r\nRouting is just as simple as using regular expressions with\r\ngroups. Each group will be provided as argument to the block.\r\n\r\nCreate a file named `routing.ru`:\r\n\r\n    require 'kontrol'\r\n    \r\n    class Routing < Kontrol::Application\r\n      map do\r\n        pages '/pages/(.*)' do |name|\r\n          text \"The path is #{ pages_path name }! \"\r\n        end\r\n     \r\n        archive '/(\\d*)/(\\d*)' do |year, month|\r\n          text \"The path is #{ archive_path year, month }! \"\r\n        end\r\n      end\r\n    end\r\n    \r\n    run Routing.new\r\n    \r\nNow run this application:\r\n\r\n    rackup routing.ru\r\n\r\nYou will now see, how regex groups and parameters are related. For\r\nexample if you browse to `localhost:9292/2008/12`, the app will\r\ndisplay `The path is /2008/12`.\r\n\r\nThe inverse operation to route recognition is route generation. That\r\nmeans a route with one or more groups can generate a url, which will\r\nbe recognized this very route.\r\n\r\nFor example the route `/page/(.*)` named page will recognize the path\r\n`/page/about`, which can be generated by using `page_path('about')`.\r\n\r\n\r\n## Templates\r\n\r\nRendering templates is as simple as calling a template file with some\r\nparameters, which are accessible inside the template as instance\r\nvariables. Additionally you will need a layout template.\r\n\r\nCreate a template named `templates/layout.rhtml`:\r\n\r\n    <html>\r\n      <body>\r\n        <%= @content %>\r\n      </body>\r\n    </html>\r\n\r\nAnd now another template named `templates/page.rhtml`:\r\n\r\n    <h1><%= @title %></h1>\r\n    <%= @body %>\r\n\r\nCreate a templates.ru file:\r\n\r\n    require 'kontrol'\r\n    \r\n    class Templates < Kontrol::Application\r\n      map do\r\n        page '/(.*)' do |name|\r\n          render \"page.rhtml\", :title => name.capitalize, :body => \"This is the body!\"\r\n        end\r\n      end\r\n    end\r\n    \r\n    run Templates.new\r\n\r\nNow run this example:\r\n\r\n    rackup templates.ru\r\n\r\nIf you browse to any path on `localhost:9292`, you will see the\r\nrendered template. Note that the title and body parameters have been\r\npassed to the `render` call.\r\n\r\n\r\n## Using GitStore\r\n\r\n[GitStore][3] is another library, which allows you to store code and\r\ndata in a convenient way in a git repository. The repository is\r\nchecked out into memory and any data may be saved back into the\r\nrepository.\r\n\r\nInstall [GitStore][] by:\r\n\r\n    $ gem sources -a http://gems.github.com\r\n    $ sudo gem install georgi-git_store\r\n\r\nWe create a Markdown file name `index.md`:\r\n\r\n    Hello World\r\n    ===========\r\n\r\n    This is the **Index** page!\r\n\r\nWe have now a simple page, which should be rendered as response. We\r\ncreate a simple app in a file `git_app.ru`:\r\n\r\n    require 'kontrol'\r\n    require 'bluecloth'\r\n    require 'git_store'\r\n\r\n    class GitApp < Kontrol::Application\r\n     \r\n      def initialize(path)\r\n        super\r\n        @store = GitStore.new(path)\r\n      end\r\n      \r\n      map do\r\n        page '/(.*)' do |name|\r\n          text BlueCloth.new(@store[name + '.md']).to_html\r\n        end\r\n      end\r\n    end\r\n\r\n    run GitApp.new\r\n\r\n\r\nAdd all the page to your git repository:\r\n\r\n    git init\r\n    git add index.md\r\n    git commit -m 'init'\r\n\r\nRun the app:\r\n\r\n    rackup git_app.ru\r\n\r\nBrowse to `http://localhost:9292/index` and you will see the rendered\r\npage generated from the markdown file.\r\n\r\nThis application runs straight from the git repository. You can even\r\ndelete the page and it will still show up over the web.\r\n\r\n\r\n[1]: http://github.com/chneukirchen/rack\r\n[2]: http://github.com/georgi/kontrol\r\n[3]: http://github.com/georgi/git_store\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Kontrol is a small web framework written in Ruby, which runs directly on Rack.","google":""}